@using System.Globalization
@typeparam TItem where TItem : notnull

<div class="pie-chart @ContainerClass">
    <div class="pie">
        @foreach (var itemData in ItemsData.Reverse())
        {
            <div class="slice @GetItemClass(itemData.Key, itemData.Value.Offset, itemData.Value.Percentage)" style="@GetItemStyle(itemData.Value.Offset, itemData.Value.Percentage, itemData.Value.Color)" @onclick="() => ActivateItem(itemData.Key)" @key="itemData.Key" />
        }
    </div>

    @if (ShowValues)
    {
        <div class="slice-values">
            @foreach (var itemData in ItemsData)
            {
                <div class="slice-value" @key="itemData.Key">
                    <small>@itemData.Value.Offset.ToString("P0").PadLeft(4, ' ')</small>
                    @if (ShowTitles)
                    {
                        <span class="slice-title">@itemData.Value.Title.</span>
                    }
                    <span>@itemData.Value.Percentage.ToString("P0").PadLeft(4, ' ')</span>
                    <small>@((itemData.Value.Offset + itemData.Value.Percentage).ToString("P0").PadLeft(4, ' '))</small>
                </div>
            }
        </div>
    }
</div>

@code {
    private string ContainerClass => ClassList.Create("selectable", Selection is not null);

    [Parameter, EditorRequired, Description("Fixed collection that determines the chart's items.")]
    public required IEnumerable<TItem> Items { get; set; }

    private Dictionary<TItem, (double Value, string? Title, double Offset, double Percentage, string Color)> ItemsData { get; set; } = [];

    [Parameter, Description("Delegate used to specify the title of each item.")]
    public Func<TItem, string?> ItemTitle { get; set; } = item => item?.ToString();

    [Parameter, Description("Delegate used to specify the value of each item.")]
    public required Func<TItem, double> ItemValue { get; set; }

    [CascadingParameter]
    private ISelection<TItem>? Selection { get; set; }

    [Parameter, Description("Item titles are visible when true. Value is <code>false</code> by default.")]
    public bool ShowTitles { get; set; }

    [Parameter, Description("Item values are visible when true. Value is <code>false</code> by default.")]
    public bool ShowValues { get; set; }

    private void ActivateItem(TItem item)
        => Selection?.Activate(item);

    private string GetItemClass(TItem item, double offset, double percentage)
    {
        var end = offset + percentage;
        return ClassList.Create("active", Selection?.IsActive(item) == true)
                        .Add("first-quarter", end < .25)
                        .Add("second-quarter", end > .25 && end <= .5)
                        .Add("third-quarter", end > .5 && end <= .75)
                        .Add("fourth-quarter", end >= .75);
    }

    private string GetItemStyle(double offset, double percentage, string color)
        => StyleList.Create("background-color", color)
                    .Add("--offset", offset.ToString(CultureInfo.InvariantCulture))
                    .Add("--percentage", percentage.ToString(CultureInfo.InvariantCulture));

    private string GetOrCreateItemColor(TItem item)
        => ItemsData.GetValueOrDefault(item).Color ?? $"#{Random.Shared.Next(16).ToString("x")}{Random.Shared.Next(16).ToString("x")}{Random.Shared.Next(16).ToString("x")}";

    protected override void OnParametersSet()
    {
        var itemTitles = Items.Select(ItemTitle).ToArray();
        var itemValues = Items.Select(ItemValue).ToArray();
        var itemValuesSum = itemValues.Sum();

        var itemPercentages = itemValues.Select(value => value / itemValuesSum).ToArray();
        var itemOffsets = itemPercentages.Select((_, index) => itemPercentages.Take(index).Sum()).ToArray();

        ItemsData = Items.Select((item, index) => (Item: item, Index: index))
                         .ToDictionary(entry => entry.Item, entry => (Value: itemValues[entry.Index],
                                                                      Title: itemTitles[entry.Index],
                                                                      Offset: itemOffsets[entry.Index],
                                                                      Percentage: itemPercentages[entry.Index],
                                                                      Color: GetOrCreateItemColor(entry.Item)));
    }

    [Description("Manually refresh the chart.")]
    public Task Refresh()
        => InvokeAsync(StateHasChanged);
}
