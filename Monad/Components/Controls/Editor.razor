@using System.ComponentModel.DataAnnotations
@using System.Globalization
@using System.Linq.Expressions
@using System.Numerics
@using System.Reflection

@typeparam TValue

<div class="editor">
    @if (Type == EditorType.MultiLine)
    {
        <textarea @bind="InputValue" @bind:after="OnInputValueChanged" />
    }
    else if (Range is { } range)
    {
        <input type="@InputType" list="@DataListProvider?.Id" min="@range.Minimum" max="@range.Maximum" @bind="InputValue" @bind:after="OnInputValueChanged" />
    }
    else
    {
        <input type="@InputType" list="@DataListProvider?.Id" @bind="InputValue" @bind:after="OnInputValueChanged" />
    }
</div>

@code {
    private const string DateFormat = "yyyy-MM-dd";
    private const string DateTimeFormat = "yyyy-MM-ddTHH:mm:ss";
    private const string MonthFormat = "yyyy-MM";
    private const string TimeFormat = "HH:mm:ss";

    [CascadingParameter]
    private IDataListProvider? DataListProvider { get; set; }

    private EditorType EffectiveEditorType => Type switch
    {
        EditorType.Auto => typeof(TValue) switch
        {
            { } valueType when valueType == typeof(DateTime) || valueType == typeof(DateTimeOffset) => EditorType.DateTime,
            { } valueType when valueType.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(INumber<>)) => EditorType.Number,
            _ => EditorType.Text
        },
        { } type => type
    };

    private string InputType => EffectiveEditorType switch
    {
        EditorType.DateTime => "datetime-local",
        EditorType.Telephone => "tel",
        { } type => type.ToString().ToLowerInvariant()
    };

    private string? InputValue { get; set; }

    private (object Minimum, object Maximum)? Range { get; set; }

    [Parameter, Description("Editor type.")]
    public EditorType Type { get; set; } = EditorType.Auto;

    [Parameter, EditorRequired, Description("Value to be edited.")]
    public required TValue? Value { get; set; }

    [Parameter, Description("Invoked when <code>Value</code> changes.")]
    public EventCallback<TValue> ValueChanged { get; set; }

    [Parameter, Description("Expression for <code>Value</code> binding.")]
    public Expression<Func<TValue?>>? ValueExpression { get; set; }

    private Task OnInputValueChanged()
    {
        if (BindConverter.TryConvertTo<TValue>(InputValue, CultureInfo.CurrentUICulture, out var value))
        {
            Value = value;
            return ValueChanged.InvokeAsync(value);
        }

        return Task.CompletedTask;
    }

    private void OnValueChanged()
    {
        InputValue = Value switch
        {
            DateTime dateTime => EffectiveEditorType switch
            {
                EditorType.Date => dateTime.ToString(DateFormat),
                EditorType.Month => dateTime.ToString(MonthFormat),
                EditorType.Time => dateTime.ToString(TimeFormat),
                _ => dateTime.ToString(DateTimeFormat)
            },
            DateTimeOffset dateTimeOffset => EffectiveEditorType switch
            {
                EditorType.Date => dateTimeOffset.ToString(DateFormat),
                EditorType.Month => dateTimeOffset.ToString(MonthFormat),
                EditorType.Time => dateTimeOffset.ToString(TimeFormat),
                _ => dateTimeOffset.ToString(DateTimeFormat)
            },
            _ => BindConverter.FormatValue(Value, CultureInfo.CurrentUICulture) as string
        };

        Range = ValueExpression is { } expression && expression.GetPropertyInfo().GetCustomAttribute<RangeAttribute>() is { } range ? (range.Minimum, range.Maximum) : null;
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        var prevValue = Value;
        await base.SetParametersAsync(parameters);
        if (!Equals(prevValue, Value))
        {
            OnValueChanged();
        }
    }
}
